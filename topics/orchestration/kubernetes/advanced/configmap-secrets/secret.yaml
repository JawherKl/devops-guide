# =============================================================================
# advanced/configmap-secrets/secret.yaml
# =============================================================================
# Secrets store sensitive data (passwords, tokens, TLS certs).
# IMPORTANT: Kubernetes Secrets are base64-encoded, NOT encrypted by default.
# For true encryption: enable Encryption at Rest in the API server, or use
# an external secrets manager (HashiCorp Vault, AWS Secrets Manager, SOPS).
#
# base64 encode:  echo -n "mysecret" | base64
# base64 decode:  echo "bXlzZWNyZXQ=" | base64 -d
#
# Secret types:
#   Opaque                    — arbitrary key/value data (most common)
#   kubernetes.io/tls         — TLS certificate + key
#   kubernetes.io/dockerconfigjson — registry pull credentials
#   kubernetes.io/service-account-token — SA token (auto-managed)
#
# Apply:  kubectl apply -f secret.yaml
# View:   kubectl get secret app-secret -o jsonpath='{.data.db-password}' | base64 -d
# =============================================================================

# ── Secret 1: Application credentials (Opaque) ───────────────────────────────
apiVersion: v1
kind: Secret
metadata:
  name: app-secret
  namespace: default
  labels:
    app: demo-api
  annotations:
    description: "Application database and API credentials"
type: Opaque
data:
  # All values MUST be base64-encoded
  # echo -n "supersecretpassword" | base64  →  c3VwZXJzZWNyZXRwYXNzd29yZA==
  db-password:  c3VwZXJzZWNyZXRwYXNzd29yZA==   # "supersecretpassword"
  db-username:  YXBwdXNlcg==                     # "appuser"
  redis-password: cmVkaXNwYXNz                    # "redispass"
  jwt-secret:   bXlzdXBlcnNlY3JldGp3dGtleQ==     # "mysupersecretjwtkey"

# Alternatively use stringData — Kubernetes base64-encodes these automatically
# stringData:
#   db-password: supersecretpassword   ← plain text, convenient for dev
#   jwt-secret: mysupersecretjwtkey

---
# ── Secret 2: TLS certificate ─────────────────────────────────────────────────
# Used by Ingress to terminate TLS (see advanced/ingress/ingress.yaml)
# In practice, generate with: cert-manager or Let's Encrypt
#
# Create from files:
#   kubectl create secret tls tls-secret \
#     --cert=tls.crt \
#     --key=tls.key
apiVersion: v1
kind: Secret
metadata:
  name: tls-secret
  namespace: default
type: kubernetes.io/tls
data:
  # Replace with actual base64-encoded cert and key
  tls.crt: LS0tLS1CRUdJTi... # base64(tls.crt)
  tls.key: LS0tLS1CRUdJTi... # base64(tls.key)

---
# ── Secret 3: Docker registry pull credentials ────────────────────────────────
# Allows Kubernetes to pull images from a private registry.
#
# Create with kubectl (preferred — handles JSON encoding automatically):
#   kubectl create secret docker-registry regcred \
#     --docker-server=registry.example.com \
#     --docker-username=myuser \
#     --docker-password=mypassword \
#     --docker-email=me@example.com
#
# Then reference in Pod spec:
#   imagePullSecrets:
#     - name: regcred
apiVersion: v1
kind: Secret
metadata:
  name: regcred
  namespace: default
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: eyJhdXRocyI6eyJyZWdpc3RyeS5leGFtcGxlLmNvbSI6eyJ1c2VybmFtZSI6Im15dXNlciIsInBhc3N3b3JkIjoibXlwYXNzd29yZCIsImF1dGgiOiJiWGwxYzJWeU9tMTVjR0Z6YzNkdmNtUT0ifX19

---
# ── Pod using Secrets via all three injection methods ─────────────────────────
apiVersion: v1
kind: Pod
metadata:
  name: secret-demo
  namespace: default
spec:
  # Pull image from private registry using secret
  imagePullSecrets:
    - name: regcred

  securityContext:
    runAsNonRoot: true
    runAsUser: 1001

  containers:
    - name: app
      image: nginx:1.25-alpine

      # ── Method 1: Individual key → env var ──────────────────────────────────
      env:
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: app-secret
              key: db-password    # decoded automatically by kubelet

        - name: DB_USERNAME
          valueFrom:
            secretKeyRef:
              name: app-secret
              key: db-username

      # ── Method 2: All keys → env vars ─────────────────────────────────────
      envFrom:
        - secretRef:
            name: app-secret

      # ── Method 3: Mount as files in a volume ──────────────────────────────
      # Files are decoded and written to disk by kubelet.
      # Path: /run/secrets/db-password  (contains the plain-text value)
      volumeMounts:
        - name: secret-vol
          mountPath: /run/secrets
          readOnly: true

      resources:
        requests:
          cpu: "50m"
          memory: "64Mi"
        limits:
          cpu: "200m"
          memory: "128Mi"

  volumes:
    - name: secret-vol
      secret:
        secretName: app-secret
        defaultMode: 0400   # owner-read only — never 0644 for secrets
        items:
          - key: db-password
            path: db-password
          - key: jwt-secret
            path: jwt-secret

  restartPolicy: Never